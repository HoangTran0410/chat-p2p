const S="ChatP2P_v2",i="chat_sessions";const R=()=>new Promise((c,r)=>{const o=indexedDB.open(S,1);o.onerror=()=>r(o.error),o.onupgradeneeded=s=>{const e=s.target.result;e.objectStoreNames.contains(i)||e.createObjectStore(i,{keyPath:"_key"}).createIndex("sessionId","sessionId",{unique:!1})},o.onsuccess=async()=>{c()}}),b=(c,r)=>new Promise((o,s)=>{const e=indexedDB.open(S,1);e.onsuccess=()=>{const a=e.result,u=a.transaction(i,"readwrite").objectStore(i),t={...r,sessionId:c,_key:`${c}_${r.peerId}`},n=u.put(t);n.onsuccess=()=>{a.close(),o()},n.onerror=()=>{a.close(),s(n.error)}},e.onerror=()=>s(e.error)}),q=c=>new Promise((r,o)=>{const s=indexedDB.open(S,1);s.onsuccess=async()=>{const e=s.result,t=e.transaction(i,"readonly").objectStore(i).index("sessionId").getAll(c);t.onsuccess=()=>{const n=t.result,d={};n.forEach(I=>{const{sessionId:x,_key:p,...h}=I;d[h.peerId]=h}),e.close(),r(d)},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)}),E=(c,r)=>new Promise((o,s)=>{const e=indexedDB.open(S,1);e.onsuccess=()=>{const a=e.result,u=a.transaction(i,"readwrite").objectStore(i),t=`${c}_${r}`,n=u.delete(t);n.onsuccess=()=>{a.close(),o()},n.onerror=()=>{a.close(),s(n.error)}},e.onerror=()=>s(e.error)}),g=c=>new Promise((r,o)=>{const s=indexedDB.open(S,1);s.onsuccess=()=>{const e=s.result,l=e.transaction(i,"readwrite").objectStore(i),t=l.index("sessionId").getAllKeys(c);t.onsuccess=()=>{const n=t.result;let d=n.length;if(d===0){e.close(),r();return}n.forEach(I=>{const x=l.delete(I);x.onsuccess=()=>{d--,d===0&&(e.close(),r())},x.onerror=()=>{e.close(),o(x.error)}})},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)});export{g as a,E as d,q as g,R as i,b as s};
