const d="ChatP2P_v2",u="chat_sessions",b="identity_keys",p="peer_keys";const q=()=>new Promise((n,r)=>{const o=indexedDB.open(d,2);o.onerror=()=>r(o.error),o.onupgradeneeded=s=>{const e=s.target.result;e.objectStoreNames.contains(u)||e.createObjectStore(u,{keyPath:"_key"}).createIndex("sessionId","sessionId",{unique:!1}),e.objectStoreNames.contains(b)||e.createObjectStore(b,{keyPath:"sessionId"}),e.objectStoreNames.contains(p)||e.createObjectStore(p,{keyPath:"peerId"}).createIndex("fingerprint","fingerprint",{unique:!1})},o.onsuccess=async()=>{n()}}),D=(n,r)=>new Promise((o,s)=>{const e=indexedDB.open(d,2);e.onsuccess=()=>{const c=e.result,t=c.transaction(u,"readwrite").objectStore(u),a={...r,sessionId:n,_key:`${n}_${r.peerId}`},i=t.put(a);i.onsuccess=()=>{c.close(),o()},i.onerror=()=>{c.close(),s(i.error)}},e.onerror=()=>s(e.error)}),x=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=async()=>{const e=s.result,a=e.transaction(u,"readonly").objectStore(u).index("sessionId").getAll(n);a.onsuccess=()=>{const i=a.result,S={};i.forEach(y=>{const{sessionId:I,_key:R,...E}=y;S[E.peerId]=E}),e.close(),r(S)},a.onerror=()=>{e.close(),o(a.error)}},s.onerror=()=>o(s.error)}),g=(n,r)=>new Promise((o,s)=>{const e=indexedDB.open(d,2);e.onsuccess=()=>{const c=e.result,t=c.transaction(u,"readwrite").objectStore(u),a=`${n}_${r}`,i=t.delete(a);i.onsuccess=()=>{c.close(),o()},i.onerror=()=>{c.close(),s(i.error)}},e.onerror=()=>s(e.error)}),P=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=()=>{const e=s.result,l=e.transaction(u,"readwrite").objectStore(u),a=l.index("sessionId").getAllKeys(n);a.onsuccess=()=>{const i=a.result;let S=i.length;if(S===0){e.close(),r();return}i.forEach(y=>{const I=l.delete(y);I.onsuccess=()=>{S--,S===0&&(e.close(),r())},I.onerror=()=>{e.close(),o(I.error)}})},a.onerror=()=>{e.close(),o(a.error)}},s.onerror=()=>o(s.error)}),w=()=>new Promise((n,r)=>{const o=indexedDB.deleteDatabase(d);o.onsuccess=()=>{n()},o.onerror=()=>{r(o.error)},o.onblocked=()=>{console.warn("Database deletion blocked"),r(new Error("Database deletion blocked"))}}),m=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=()=>{const e=s.result,t=e.transaction(b,"readwrite").objectStore(b).put(n);t.onsuccess=()=>{e.close(),r()},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)}),B=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=()=>{const e=s.result,t=e.transaction(b,"readonly").objectStore(b).get(n);t.onsuccess=()=>{e.close(),r(t.result||null)},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)}),N=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=()=>{const e=s.result,t=e.transaction(p,"readwrite").objectStore(p).put(n);t.onsuccess=()=>{e.close(),r()},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)}),O=n=>new Promise((r,o)=>{const s=indexedDB.open(d,2);s.onsuccess=()=>{const e=s.result,t=e.transaction(p,"readonly").objectStore(p).get(n);t.onsuccess=()=>{e.close(),r(t.result||null)},t.onerror=()=>{e.close(),o(t.error)}},s.onerror=()=>o(s.error)});export{m as a,B as b,w as c,D as d,x as e,g as f,O as g,P as h,q as i,N as s};
