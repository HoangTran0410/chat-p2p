const g="ChatP2P_v2",i="chat_sessions";const D=()=>new Promise((t,n)=>{const e=indexedDB.open(g,1);e.onerror=()=>n(e.error),e.onupgradeneeded=o=>{const s=o.target.result;s.objectStoreNames.contains(i)||s.createObjectStore(i,{keyPath:"_key"}).createIndex("sessionId","sessionId",{unique:!1})},e.onsuccess=async()=>{await y(),t()}}),y=async()=>new Promise(t=>{const n=indexedDB.open("ChatP2P_v1",1);n.onerror=()=>t(),n.onsuccess=async()=>{const e=n.result;if(!e.objectStoreNames.contains("chat_sessions")){e.close(),t();return}try{const c=e.transaction("chat_sessions","readonly").objectStore("chat_sessions").getAll();c.onsuccess=async()=>{const l=c.result;if(l.length===0){e.close(),t();return}const d=localStorage.getItem("synapse_user_id");if(!d){console.warn("No user ID found, skipping migration"),e.close(),t();return}console.log(`Migrating ${l.length} chats to v2 with session support...`),await Promise.all(l.map(r=>p(d,r))),console.log("Migration complete. Deleting old database..."),e.close(),indexedDB.deleteDatabase("ChatP2P_v1"),t()},c.onerror=()=>{e.close(),t()}}catch(o){console.error("Migration error:",o),e.close(),t()}}}),_=async t=>{const n="synapse_chats",e=localStorage.getItem(n);if(e)try{const o=JSON.parse(e);console.log("Migrating chats from localStorage...",Object.keys(o).length),await Promise.all(Object.values(o).map(s=>p(t,s))),localStorage.removeItem(n),console.log("LocalStorage migration complete.")}catch(o){console.error("LocalStorage migration failed:",o)}},p=(t,n)=>new Promise((e,o)=>{const s=indexedDB.open(g,1);s.onsuccess=()=>{const c=s.result,d=c.transaction(i,"readwrite").objectStore(i),r={...n,sessionId:t,_key:`${t}_${n.peerId}`},a=d.put(r);a.onsuccess=()=>{c.close(),e()},a.onerror=()=>{c.close(),o(a.error)}},s.onerror=()=>o(s.error)}),I=t=>new Promise((n,e)=>{const o=indexedDB.open(g,1);o.onsuccess=async()=>{const s=o.result;await _(t);const r=s.transaction(i,"readonly").objectStore(i).index("sessionId").getAll(t);r.onsuccess=()=>{const a=r.result,u={};a.forEach(S=>{const{sessionId:m,_key:b,...h}=S;u[h.peerId]=h}),s.close(),n(u)},r.onerror=()=>{s.close(),e(r.error)}},o.onerror=()=>e(o.error)}),w=(t,n)=>new Promise((e,o)=>{const s=indexedDB.open(g,1);s.onsuccess=()=>{const c=s.result,d=c.transaction(i,"readwrite").objectStore(i),r=`${t}_${n}`,a=d.delete(r);a.onsuccess=()=>{c.close(),e()},a.onerror=()=>{c.close(),o(a.error)}},s.onerror=()=>o(s.error)}),x=t=>new Promise((n,e)=>{const o=indexedDB.open(g,1);o.onsuccess=()=>{const s=o.result,l=s.transaction(i,"readwrite").objectStore(i),r=l.index("sessionId").getAllKeys(t);r.onsuccess=()=>{const a=r.result;let u=a.length;if(u===0){s.close(),n();return}a.forEach(S=>{const m=l.delete(S);m.onsuccess=()=>{u--,u===0&&(s.close(),n())},m.onerror=()=>{s.close(),e(m.error)}})},r.onerror=()=>{s.close(),e(r.error)}},o.onerror=()=>e(o.error)});export{x as a,w as d,I as g,D as i,p as s};
