const s={name:"ECDSA",namedCurve:"P-256"},u={name:"ECDH",namedCurve:"P-256"},K={name:"AES-GCM",length:256};async function g(){const e=await crypto.subtle.generateKey(s,!0,["sign","verify"]);return{publicKey:e.publicKey,privateKey:e.privateKey}}async function h(){const e=await crypto.subtle.generateKey(u,!0,["deriveKey","deriveBits"]);return{publicKey:e.publicKey,privateKey:e.privateKey}}async function v(e,t){const n=await crypto.subtle.deriveBits({name:"ECDH",public:t},e,256),r=await crypto.subtle.importKey("raw",n,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:new TextEncoder().encode("chat-p2p-e2ee-v1"),info:new TextEncoder().encode("aes-key")},r,K,!0,["encrypt","decrypt"])}async function A(e,t){const r=new TextEncoder().encode(e),a=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},t,r);return{iv:c(a.buffer),ciphertext:c(i)}}async function S(e,t){const n=o(e.iv),r=o(e.ciphertext),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(n)},t,r);return new TextDecoder().decode(a)}async function l(e,t){const n=typeof e=="string"?new TextEncoder().encode(e):e,r=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},t,n);return c(r)}async function d(e,t,n){const r=typeof e=="string"?new TextEncoder().encode(e):e,a=o(t);try{return await crypto.subtle.verify({name:"ECDSA",hash:"SHA-256"},n,a,r)}catch{return!1}}async function p(e){var i;const t=await crypto.subtle.exportKey("raw",e),n=await crypto.subtle.digest("SHA-256",t),a=Array.from(new Uint8Array(n)).map(f=>f.toString(16).padStart(2,"0")).join("");return((i=a.match(/.{1,4}/g))==null?void 0:i.join(" "))||a}async function m(e){return(await p(e)).split(" ").slice(0,4).join(" ")}async function x(e){const t=await crypto.subtle.exportKey("jwk",e.publicKey),n=await crypto.subtle.exportKey("jwk",e.privateKey);return{publicKey:t,privateKey:n}}async function y(e){return crypto.subtle.exportKey("jwk",e)}async function P(e){const t=await crypto.subtle.importKey("jwk",e.publicKey,s,!0,["verify"]),n=await crypto.subtle.importKey("jwk",e.privateKey,s,!0,["sign"]);return{publicKey:t,privateKey:n}}async function b(e){return crypto.subtle.importKey("jwk",e,s,!0,["verify"])}async function w(e){return crypto.subtle.importKey("jwk",e,u,!0,[])}function c(e){const t=new Uint8Array(e);let n="";for(let r=0;r<t.byteLength;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function o(e){const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t.charCodeAt(r);return n.buffer}async function E(e,t){const n=await y(e.publicKey),r=await y(t.publicKey),a=JSON.stringify(r),i=await l(a,e.privateKey);return{identityPubKey:n,sessionPubKey:r,signature:i}}async function C(e){try{const t=await b(e.identityPubKey),n=JSON.stringify(e.sessionPubKey);if(!await d(n,e.signature,t))return{valid:!1};const a=await w(e.sessionPubKey),i=await p(t);return{valid:!0,identityKey:t,sessionKey:a,fingerprint:i}}catch(t){return console.error("Key exchange verification failed:",t),{valid:!1}}}export{S as a,x as b,E as c,v as d,A as e,m as f,p as g,h,P as i,g as j,C as v};
