const l="ChatP2P_v2",i="chat_sessions";const h=()=>new Promise((r,n)=>{const s=indexedDB.open(l,1);s.onerror=()=>n(s.error),s.onupgradeneeded=o=>{const e=o.target.result;e.objectStoreNames.contains(i)||e.createObjectStore(i,{keyPath:"_key"}).createIndex("sessionId","sessionId",{unique:!1})},s.onsuccess=async()=>{r()}}),p=(r,n)=>new Promise((s,o)=>{const e=indexedDB.open(l,1);e.onsuccess=()=>{const a=e.result,b=a.transaction(i,"readwrite").objectStore(i),t={...n,sessionId:r,_key:`${r}_${n.peerId}`},c=b.put(t);c.onsuccess=()=>{a.close(),s()},c.onerror=()=>{a.close(),o(c.error)}},e.onerror=()=>o(e.error)}),q=r=>new Promise((n,s)=>{const o=indexedDB.open(l,1);o.onsuccess=async()=>{const e=o.result,t=e.transaction(i,"readonly").objectStore(i).index("sessionId").getAll(r);t.onsuccess=()=>{const c=t.result,d={};c.forEach(D=>{const{sessionId:S,_key:I,...x}=D;d[x.peerId]=x}),e.close(),n(d)},t.onerror=()=>{e.close(),s(t.error)}},o.onerror=()=>s(o.error)}),B=(r,n)=>new Promise((s,o)=>{const e=indexedDB.open(l,1);e.onsuccess=()=>{const a=e.result,b=a.transaction(i,"readwrite").objectStore(i),t=`${r}_${n}`,c=b.delete(t);c.onsuccess=()=>{a.close(),s()},c.onerror=()=>{a.close(),o(c.error)}},e.onerror=()=>o(e.error)}),E=r=>new Promise((n,s)=>{const o=indexedDB.open(l,1);o.onsuccess=()=>{const e=o.result,u=e.transaction(i,"readwrite").objectStore(i),t=u.index("sessionId").getAllKeys(r);t.onsuccess=()=>{const c=t.result;let d=c.length;if(d===0){e.close(),n();return}c.forEach(D=>{const S=u.delete(D);S.onsuccess=()=>{d--,d===0&&(e.close(),n())},S.onerror=()=>{e.close(),s(S.error)}})},t.onerror=()=>{e.close(),s(t.error)}},o.onerror=()=>s(o.error)}),R=()=>new Promise((r,n)=>{const s=indexedDB.deleteDatabase(l);s.onsuccess=()=>{r()},s.onerror=()=>{n(s.error)},s.onblocked=()=>{console.warn("Database deletion blocked"),n(new Error("Database deletion blocked"))}});export{E as a,R as c,B as d,q as g,h as i,p as s};
