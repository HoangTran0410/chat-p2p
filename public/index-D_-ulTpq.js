import{r as a,$ as jt,N as Kt,j as J,X as Nt,O as At,Q as Ot}from"./vendor--tW1iPYm.js";import{c as Ut,v as Ft,d as It,e as Tt,a as Gt,b as Le,i as ze,g as We,f as $e,h as De,j as Jt}from"./services/crypto-DOdyDEE6.js";import{g as Be,s as qe,a as Ve,b as Ht,d as ce,i as Lt,e as Xe,f as zt,h as Wt}from"./services/db-C51VnwX1.js";import{g as me,a as $t,b as Bt,s as Ze,d as Se,e as qt}from"./services/storage-DVVzbgBO.js";import{C as Vt}from"./components/chatsidebar-CyBs4-Ve.js";import{C as Xt}from"./components/chatwindow-D1SMhF-B.js";import{S as Zt}from"./components/settingsmodal-CFeZ0iot.js";import{S as Qt}from"./components/syncmodal-DBKQqyJ2.js";import{N as Yt}from"./components/newsessiondialog-BYGLC33Y.js";import{K as es}from"./components/keychangewarningmodal-xm_UvFBO.js";import{R as ts}from"./components/roomchatwindow-CNkkb4_g.js";import{C as ss}from"./components/createroommodal-By-BRM49.js";import{J as ns}from"./components/joinroommodal-DhkQ9qJn.js";import"./index-D_-ulTpq.js";import"./components/sessionswitcher-C0a3MZR2.js";(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const M of document.querySelectorAll('link[rel="modulepreload"]'))B(M);new MutationObserver(M=>{for(const I of M)if(I.type==="childList")for(const q of I.addedNodes)q.tagName==="LINK"&&q.rel==="modulepreload"&&B(q)}).observe(document,{childList:!0,subtree:!0});function T(M){const I={};return M.integrity&&(I.integrity=M.integrity),M.referrerPolicy&&(I.referrerPolicy=M.referrerPolicy),M.crossOrigin==="use-credentials"?I.credentials="include":M.crossOrigin==="anonymous"?I.credentials="omit":I.credentials="same-origin",I}function B(M){if(M.ep)return;M.ep=!0;const I=T(M);fetch(M.href,I)}})();function Es(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}const et={host:"fbaio.xyz",port:443,path:"/peer",secure:!0,debug:3},tt=50,os=({config:r=et,sessionId:n,onMessageReceived:T,onConnectionOpened:B,onConnectionClosed:M,onConnectionLimitExceeded:I})=>{const[q,S]=a.useState(""),[h,$]=a.useState(null),D=a.useRef(new Map),V=a.useRef([]),[H,X]=a.useState({}),[Y,Z]=a.useState(!1),[se,x]=a.useState(!1),[U,L]=a.useState(null),[ue,le]=a.useState(null),G=(e,s)=>{X(i=>({...i,[e]:s}))},C=a.useCallback(e=>{G(e.peer,"connecting"),e.on("open",()=>{if(D.current.size>=tt){const s=V.current[0];if(s){const i=D.current.get(s);i&&i.close(),D.current.delete(s),V.current=V.current.filter(f=>f!==s),G(s,"disconnected"),M(s),I&&I(s)}}D.current.set(e.peer,e),V.current.push(e.peer),G(e.peer,"connected"),B(e.peer),e.send({type:"presence",status:"online"})}),e.on("data",s=>{s&&typeof s=="object"&&s.type==="presence"||T(e.peer,s)}),e.on("close",()=>{D.current.delete(e.peer),V.current=V.current.filter(s=>s!==e.peer),G(e.peer,"disconnected"),M(e.peer)}),e.on("error",s=>{console.error("Connection-specific error:",s),D.current.delete(e.peer),G(e.peer,"failed")})},[B,M,T]);a.useCallback(()=>{h&&(h.destroy(),$(null)),D.current.clear(),X({}),Z(!1)},[h]);const y=a.useCallback(e=>{x(!0);const s=window.Peer||jt,i=new s(e,{host:r.host,port:r.port,path:r.path,secure:r.secure,debug:r.debug||0});return i.on("open",f=>{console.log("My Peer ID is: "+f),Z(!0),x(!1),L(null)}),i.on("connection",f=>{C(f)}),i.on("disconnected",()=>{console.log("Peer disconnected from server."),Z(!1),setTimeout(()=>{i&&!i.destroyed&&(console.log("Attempting to reconnect..."),x(!0),i.reconnect())},3e3)}),i.on("error",f=>{if(console.error("PeerJS error:",f),x(!1),f.type==="unavailable-id")L("ID is already taken. Please choose another."),Z(!1);else if(f.message&&f.message.includes("is taken"))L(`ID is taken: ${f.message}`),Z(!1);else if(f.type==="peer-unavailable"){const d=(f.message||"").match(/Could not connect to peer (.*)/);d&&d[1]?(G(d[1],"failed"),le(`User '${d[1]}' not found or offline.`)):le("Peer not found or offline.")}else f.type==="network"||f.type==="disconnected"?(Z(!1),L("Network error. Reconnecting..."),setTimeout(()=>{i&&!i.destroyed&&(x(!0),i.reconnect())},3e3)):L("Connection error: "+(f.message||"Unknown error"))}),$(i),i},[C]);a.useEffect(()=>{if(!n)return;S(n);const e=y(n),s=()=>{e==null||e.destroy()};return window.addEventListener("beforeunload",s),()=>{window.removeEventListener("beforeunload",s),e==null||e.destroy()}},[n,r]);const b=a.useCallback(e=>{!e||e===q||(h&&h.destroy(),D.current.clear(),X({}),Z(!1),L(null),le(null),S(e),y(e))},[q,h,y]),K=a.useCallback(e=>{if(!(!h||!Y)){if(D.current.has(e)){const s=D.current.get(e);if(s!=null&&s.open){G(e,"connected");return}}G(e,"connecting");try{const s=h.connect(e,{reliable:!0});C(s),setTimeout(()=>{X(i=>i[e]==="connecting"?{...i,[e]:"failed"}:i)},1e4)}catch(s){console.error("Connect error",s),G(e,"failed")}}},[h,Y,C]),v=a.useCallback(e=>{const s=D.current.get(e);s&&(s.close(),D.current.delete(e)),G(e,"disconnected")},[]),ne=a.useCallback((e,s)=>{const i=D.current.get(e);return i&&i.open?(i.send(s),!0):!1},[]);return{myId:q,isReady:Y,isReconnecting:se,peerError:U,connectionError:ue,resetConnectionError:()=>le(null),connectionStates:H,activeConnectionsCount:Array.from(D.current.values()).filter(e=>e==null?void 0:e.open).length,connectToPeer:K,disconnectPeer:v,sendMessage:ne,updateId:b}};function rs({sessionId:r,onKeyChange:n}){const[T,B]=a.useState(!1),[M,I]=a.useState(null),[q,S]=a.useState(null),h=a.useRef(null),$=a.useRef(null),D=a.useRef(new Map),[,V]=a.useState({}),H=a.useCallback(()=>V({}),[]);a.useEffect(()=>{if(!r)return;(async()=>{try{const y=await Ht(r);if(y){const v=await ze({publicKey:y.identityPubKey,privateKey:y.identityPrivKey});h.current=v}else{const v=await Jt();h.current=v;const ne=await Le(v),z={sessionId:r,identityPubKey:ne.publicKey,identityPrivKey:ne.privateKey,createdAt:Date.now()};await Ve(z)}$.current=await De();const b=await We(h.current.publicKey),K=await $e(h.current.publicKey);I(b),S(K),B(!0)}catch(y){console.error("Failed to initialize encryption:",y)}})()},[r]);const X=a.useCallback(async()=>!h.current||!$.current?null:Ut(h.current,$.current),[]),Y=a.useCallback(async(C,y)=>{if(!$.current)return!1;try{const b=await Ft(y);if(!b.valid||!b.sessionKey||!b.fingerprint)return console.warn("Invalid key exchange from",C),!1;const K=await It($.current.privateKey,b.sessionKey),v=await Be(C);let ne=!1;v&&v.fingerprint!==b.fingerprint&&(ne=!0,n&&n(C,v.fingerprint,b.fingerprint)),D.current.set(C,{sessionKey:K,fingerprint:b.fingerprint,verified:(v==null?void 0:v.verified)||!1,keyChanged:ne});const z={peerId:C,identityPubKey:y.identityPubKey,fingerprint:b.fingerprint,firstSeen:(v==null?void 0:v.firstSeen)||Date.now(),lastSeen:Date.now(),verified:(v==null?void 0:v.verified)||!1};return await qe(z),H(),!0}catch(b){return console.error("Key exchange failed:",b),!1}},[n,H]),Z=a.useCallback(async(C,y)=>{const b=D.current.get(C);if(!(b!=null&&b.sessionKey))return console.warn("No session key for peer:",C),null;try{return await Tt(y,b.sessionKey)}catch(K){return console.error("Encryption failed:",K),null}},[]),se=a.useCallback(async(C,y)=>{const b=D.current.get(C);if(!(b!=null&&b.sessionKey))return console.warn("No session key for peer:",C),null;try{return await Gt(y,b.sessionKey)}catch(K){return console.error("Decryption failed:",K),null}},[]),x=a.useCallback(C=>{var y;return((y=D.current.get(C))==null?void 0:y.fingerprint)||null},[]),U=a.useCallback(C=>{var y;return D.current.has(C)&&((y=D.current.get(C))==null?void 0:y.sessionKey)!==null},[]),L=a.useCallback(async C=>{const y=D.current.get(C);if(!y)return;y.verified=!0,y.keyChanged=!1;const b=await Be(C);b&&(b.verified=!0,await qe(b)),H()},[H]),ue=a.useCallback(async()=>{if(!h.current)return null;try{const C=await Le(h.current);return JSON.stringify({sessionId:r,keys:C,exportedAt:Date.now()},null,2)}catch(C){return console.error("Failed to export keys:",C),null}},[r]),le=a.useCallback(async C=>{var y,b;try{const K=JSON.parse(C);if(!((y=K.keys)!=null&&y.publicKey)||!((b=K.keys)!=null&&b.privateKey))throw new Error("Invalid key format");const v=await ze(K.keys);h.current=v;const ne={sessionId:r,identityPubKey:K.keys.publicKey,identityPrivKey:K.keys.privateKey,createdAt:K.exportedAt||Date.now()};await Ve(ne);const z=await We(v.publicKey),e=await $e(v.publicKey);return I(z),S(e),$.current=await De(),!0}catch(K){return console.error("Failed to import keys:",K),!1}},[r]),G=a.useCallback(async()=>{$.current=await De(),D.current.clear(),H()},[H]);return{isReady:T,myFingerprint:M,myShortFingerprint:q,identityKeyPair:h.current,sessionKeyPair:$.current,peerStates:D.current,createKeyExchange:X,handleKeyExchange:Y,encrypt:Z,decrypt:se,getPeerFingerprint:x,hasPeerKey:U,markPeerVerified:L,exportMyKeys:ue,importMyKeys:le,regenerateSessionKey:G}}const as=()=>{const r=window.location.hash;let n=null,T=null;return r.startsWith("#connect=")?(n=r.slice(9),window.history.replaceState(null,"",window.location.pathname+window.location.search)):r.startsWith("#room=")&&(T=r.slice(6),window.history.replaceState(null,"",window.location.pathname+window.location.search)),{pendingConnect:n,pendingRoom:T}},{pendingConnect:is,pendingRoom:Qe}=as(),cs=Kt(r=>({viewMode:Qe?"rooms":"chats",selectedPeerId:null,activeRoomId:null,showMobileDashboard:!1,showSettings:!1,showNewSessionDialog:!1,showCreateRoomModal:!1,showJoinRoomModal:!1,pendingConnectPeerId:is,pendingRoomId:Qe,setViewMode:n=>r({viewMode:n}),setSelectedPeerId:n=>r({selectedPeerId:n}),setActiveRoomId:n=>r({activeRoomId:n}),setShowMobileDashboard:n=>r({showMobileDashboard:n}),setShowSettings:n=>r({showSettings:n}),setShowNewSessionDialog:n=>r({showNewSessionDialog:n}),setShowCreateRoomModal:n=>r({showCreateRoomModal:n}),setShowJoinRoomModal:n=>r({showJoinRoomModal:n}),setPendingConnectPeerId:n=>r({pendingConnectPeerId:n}),setPendingRoomId:n=>r({pendingRoomId:n}),selectChat:n=>r({selectedPeerId:n,activeRoomId:null,showMobileDashboard:!1,viewMode:"chats"}),selectRoom:n=>r({activeRoomId:n,selectedPeerId:null,showMobileDashboard:!1,viewMode:"rooms"}),backToSidebar:()=>r({selectedPeerId:null,activeRoomId:null,showMobileDashboard:!1})})),Pe=64*1024,js=50*1024*1024,ls=5e3,us=15e3,ds=50,Ye="chat_p2p_rooms_",fs=({myId:r,myName:n,sendMessage:T,connectToPeer:B,disconnectPeer:M,connectionStates:I,isReady:q})=>{const[S,h]=a.useState({}),[$,D]=a.useState(null),[V,H]=a.useState(!1);a.useEffect(()=>{if(r){try{const e=localStorage.getItem(Ye+r);if(e){const s=JSON.parse(e);Object.keys(s).forEach(i=>{s[i].members=s[i].members.map(f=>({...f,isOnline:f.peerId===r}))}),h(s)}else h({});H(!0)}catch(e){console.error("Failed to load rooms from storage:",e),h({}),H(!0)}return()=>H(!1)}},[r]),a.useEffect(()=>{!r||!V||localStorage.setItem(Ye+r,JSON.stringify(S))},[S,r,V]),a.useEffect(()=>{!q||!V||Object.values(S).forEach(e=>{e.hostId!==r&&(console.log("[GroupChat] Restoring connection to room host:",e.hostId),B(e.hostId),Z.current.set(e.roomId,e.hostId))})},[q,V]);const X=a.useRef(new Map),Y=a.useRef(new Map),Z=a.useRef(new Map),se=(e,s)=>{const i=s.replace(/[^a-zA-Z0-9]/g,"");return`room_${e}_${i}_${Date.now().toString(36)}`},x=e=>{if(e.startsWith("room_")){const s=e.split("_");if(s.length>=2)return s[1]}return e.startsWith("room-")?e.slice(5):null},U=a.useCallback((e,s,i,f)=>{const c={type:s,roomId:i,senderId:r,payload:f,timestamp:Date.now()};return T(e,c)},[r,T]),L=a.useCallback((e,s,i,f)=>{const c=S[e];!c||c.hostId!==r||c.members.forEach(d=>{d.peerId!==r&&d.peerId!==f&&U(d.peerId,s,e,i)})},[S,r,U]),ue=a.useCallback(e=>{const s=se(r,e),i={peerId:r,name:n,joinedAt:Date.now(),priority:0,isHost:!0,isOnline:!0},f={roomId:s,name:e,hostId:r,originalHostId:r,members:[i],messages:[],createdAt:Date.now(),lastUpdated:Date.now()};return h(c=>({...c,[s]:f})),D(s),console.log("[GroupChat] Created room:",s),s},[r,n]),le=a.useCallback(e=>{if(!q){console.error("[GroupChat] Not ready to join room");return}let s=e,i=null;if(e.startsWith("room_")||e.startsWith("room-")?i=x(e):(i=e,s=`room-${i}`),!i){console.error("[GroupChat] Invalid room ID or host ID");return}Z.current.set(s,i),B(i),console.log("[GroupChat] Connecting to room host:",i,"for room:",s)},[q,B]);a.useEffect(()=>{Z.current.forEach((e,s)=>{I[e]==="connected"&&(U(e,"room_join_request",s,{name:n}),console.log("[GroupChat] Sent join request to:",e),Z.current.delete(s))})},[I,U,n]);const G=a.useCallback(e=>{const s=S[e];if(!s)return;s.hostId!==r?(U(s.hostId,"room_member_left",e,{member:{peerId:r}}),M(s.hostId)):(L(e,"room_close",{}),s.members.forEach(f=>{f.peerId!==r&&M(f.peerId)}));const i=X.current.get(e);i&&(clearInterval(i),X.current.delete(e)),h(f=>{const{[e]:c,...d}=f;return d}),$===e&&D(null),console.log("[GroupChat] Left room:",e)},[S,r,$,U,M,L]),C=a.useCallback(e=>{const s=S[e];!s||s.hostId!==r||G(e)},[S,r,G]),y=a.useCallback((e,s)=>{const i=S[e];if(!i||!s.trim())return;const f=me(),c={messageId:f,content:s.trim(),type:"text"},d={id:f,senderId:r,content:s.trim(),timestamp:Date.now(),status:"sent",type:"text"};i.hostId===r?(h(_=>{const m=_[e];return m?{..._,[e]:{...m,messages:[...m.messages,d],lastUpdated:Date.now()}}:_}),L(e,"room_message",c)):(U(i.hostId,"room_message",e,c),h(_=>{const m=_[e];return m?{..._,[e]:{...m,messages:[...m.messages,{...d,status:"sending"}],lastUpdated:Date.now()}}:_}))},[S,r,L,U]),b=a.useCallback(e=>{const s=S[e];if(!s)return;const i=s.members.filter(c=>c.peerId!==s.hostId&&c.isOnline).sort((c,d)=>c.priority-d.priority);if(i.length===0){console.log("[GroupChat] No candidates for host migration");return}if(i[0].peerId===r){console.log("[GroupChat] I am becoming the new host"),h(d=>{const _=d[e];if(!_)return d;const m=_.members.map(R=>({...R,isHost:R.peerId===r,isOnline:R.peerId===s.hostId?!1:R.isOnline}));return{...d,[e]:{..._,hostId:r,members:m,lastUpdated:Date.now()}}});const c={newHostId:r,newHostPeerId:r,members:s.members.map(d=>({...d,isHost:d.peerId===r,isOnline:d.peerId===s.hostId?!1:d.isOnline}))};s.members.forEach(d=>{d.peerId!==r&&d.peerId!==s.hostId&&U(d.peerId,"room_host_changed",e,c)})}},[S,r,U]),K=a.useCallback(e=>{const s=X.current.get(e);s&&clearInterval(s);const i=S[e];if(!i||i.hostId===r)return;Y.current.set(e,Date.now());const f=setInterval(()=>{const c=S[e];if(!c){clearInterval(f),X.current.delete(e);return}U(c.hostId,"room_ping",e,{});const d=Y.current.get(e)||0;Date.now()-d>us&&(console.log("[GroupChat] Host timeout, starting migration"),b(e))},ls);X.current.set(e,f)},[S,r,U,b]),v=a.useCallback((e,s)=>{if(!s||typeof s!="object"||!s.type||!s.roomId||!s.type.startsWith("room_"))return!1;const i=s,{type:f,roomId:c,senderId:d,payload:_}=i;switch(console.log("[GroupChat] Received:",f,"from:",d),f){case"room_join_request":{const m=S[c];if(!m||m.hostId!==r)break;const R=m.members.findIndex(N=>N.peerId===d);let p;if(R!==-1)p=[...m.members],p[R]={...p[R],name:(_==null?void 0:_.name)||p[R].name,isOnline:!0};else{if(m.members.length>=ds){U(d,"room_join_reject",c,{reason:"Room is full"});break}const N={peerId:d,name:_==null?void 0:_.name,joinedAt:Date.now(),priority:m.members.length,isHost:!1,isOnline:!0};p=[...m.members,N]}h(N=>({...N,[c]:{...N[c],members:p,lastUpdated:Date.now()}}));const P={roomName:m.name,members:p,messages:m.messages.slice(-100),yourPriority:R!==-1?p[R].priority:p[p.length-1].priority};U(d,"room_join_accept",c,P),L(c,"room_member_joined",{member:R!==-1?p[R]:p[p.length-1]},d);break}case"room_join_accept":{const m=_,R={roomId:c,name:m.roomName,hostId:d,originalHostId:d,members:m.members,messages:m.messages||[],createdAt:Date.now(),lastUpdated:Date.now()};h(p=>({...p,[c]:R})),D(c),setTimeout(()=>K(c),1e3),console.log("[GroupChat] Joined room:",c);break}case"room_join_reject":{console.log("[GroupChat] Join rejected:",_==null?void 0:_.reason),M(d);break}case"room_message":{const m=S[c];if(!m)break;const R=_;if(m.hostId===r){const p={id:R.messageId,senderId:d,content:R.content,timestamp:Date.now(),status:"delivered",type:R.type,file:R.file};h(P=>{const N=P[c];return N?{...P,[c]:{...N,messages:[...N.messages,p],lastUpdated:Date.now()}}:P}),m.members.forEach(P=>{P.peerId!==r&&U(P.peerId,"room_message",c,{...R,senderPeerId:d})})}else{const p=_.senderPeerId||d,P={id:R.messageId,senderId:p,content:R.content,timestamp:Date.now(),status:"delivered",type:R.type,file:R.file};h(N=>{const oe=N[c];return oe?oe.messages.some(ae=>ae.id===P.id)?{...N,[c]:{...oe,messages:oe.messages.map(ae=>ae.id===P.id?{...ae,status:"delivered"}:ae),lastUpdated:Date.now()}}:{...N,[c]:{...oe,messages:[...oe.messages,P],lastUpdated:Date.now()}}:N})}break}case"room_member_joined":{if(!S[c])break;const{member:R}=_;h(p=>{const P=p[c];return!P||P.members.some(N=>N.peerId===R.peerId)?p:{...p,[c]:{...P,members:[...P.members,R],lastUpdated:Date.now()}}});break}case"room_member_left":{const m=S[c];if(!m)break;const{member:R}=_;m.hostId===r?(h(p=>{const P=p[c];if(!P)return p;const N=P.members.filter(oe=>oe.peerId!==R.peerId);return{...p,[c]:{...P,members:N,lastUpdated:Date.now()}}}),L(c,"room_member_left",{member:R},R.peerId)):h(p=>{const P=p[c];return P?{...p,[c]:{...P,members:P.members.filter(N=>N.peerId!==R.peerId),lastUpdated:Date.now()}}:p});break}case"room_host_changed":{const{newHostId:m,members:R}=_;h(p=>{const P=p[c];return P?{...p,[c]:{...P,hostId:m,members:R||P.members,lastUpdated:Date.now()}}:p}),m!==r&&(B(m),setTimeout(()=>K(c),1e3));break}case"room_close":{G(c);break}case"room_ping":{const m=S[c];if(!m||m.hostId!==r)break;U(d,"room_pong",c,{});break}case"room_pong":{Y.current.set(c,Date.now());break}default:console.log("[GroupChat] Unknown message type:",f)}return!0},[S,r,U,L,M,B,G,K]),ne=a.useCallback(e=>{const s=S[e];return(s==null?void 0:s.hostId)===r},[S,r]),z=a.useCallback(e=>{const s=S[e];if(s)return s.members.find(i=>i.isHost)},[S]);return a.useEffect(()=>()=>{X.current.forEach(e=>clearInterval(e)),X.current.clear()},[]),{rooms:S,activeRoomId:$,setActiveRoomId:D,createRoom:ue,joinRoom:le,leaveRoom:G,closeRoom:C,sendRoomMessage:y,isHost:ne,getRoomHost:z,handleRoomProtocol:v}};function ms(){var Je,He;const{setViewMode:r,selectedPeerId:n,setSelectedPeerId:T,showMobileDashboard:B,setShowMobileDashboard:M,showSettings:I,showNewSessionDialog:q,setShowNewSessionDialog:S,showCreateRoomModal:h,setShowCreateRoomModal:$,showJoinRoomModal:D,setShowJoinRoomModal:V,pendingConnectPeerId:H,setPendingConnectPeerId:X,pendingRoomId:Y,setPendingRoomId:Z}=cs(),[se,x]=a.useState({}),[U,L]=a.useState(!1),[ue,le]=a.useState({}),[G,C]=a.useState([]),[y,b]=a.useState(""),[K,v]=a.useState(()=>{const o=localStorage.getItem("peer_config");return o?JSON.parse(o):et}),[ne,z]=a.useState("idle"),[e,s]=a.useState(null),[i,f]=a.useState(null),[c,d]=a.useState(null),[_,m]=a.useState(null),[R,p]=a.useState(null),[P,N]=a.useState(null),oe=a.useRef(new Map),ee=a.useRef("");a.useEffect(()=>{ee.current=y},[y]);const ae=a.useRef(()=>!1),xe=a.useRef(async()=>!1),Ce=a.useRef(async()=>null),ve=a.useRef(()=>{}),Ee=a.useRef(()=>!1),je=a.useRef(()=>!1);a.useEffect(()=>{(async()=>{try{await Lt();let t=$t(),g=Bt();if(t.length===0){const j=me(),A={id:j,createdAt:Date.now()};Ze(A),Se(j),t=[A],g=j}else(!g||!t.find(j=>j.id===g))&&(g=t[0].id,Se(g));C(t),b(g);const E=await Xe(g);x(E)}catch(t){console.error("Failed to init storage:",t)}finally{L(!0)}})()},[]);const nt=o=>{v(o),localStorage.setItem("peer_config",JSON.stringify(o))},Re=a.useCallback((o,t)=>{var F;if(t&&typeof t=="object"&&((F=t.type)!=null&&F.startsWith("room_"))){je.current(o,t);return}if(t&&typeof t=="object"&&t.type==="typing"){le(u=>({...u,[o]:t.isTyping}));return}if(t&&typeof t=="object"&&t.type==="presence")return;if(t&&typeof t=="object"&&t.type==="key_exchange"){const u=Ee.current(o);xe.current(o,t).then(l=>{l&&(console.log("Key exchange completed with",o),u||Ce.current().then(w=>{w&&ae.current(o,{type:"key_exchange",...w})}))});return}if(t&&typeof t=="object"&&t.type==="encrypted_message"){Ue.current(o,t.payload).then(u=>{if(u)try{const l=JSON.parse(u);ve.current(o,{...l,_encrypted:!0})}catch{console.error("Failed to parse decrypted message")}});return}if(t&&typeof t=="object"&&t.type==="receipt"){const{messageId:u,status:l,timestamp:w}=t;x(k=>{const O=k[o];if(!O)return k;const Q=O.messages.map(re=>{if(re.id===u){if(l==="delivered")return{...re,status:"delivered",receivedAt:w};if(l==="read")return{...re,status:"read",readAt:w}}return re}),W={...O,messages:Q};return ce(ee.current,W),{...k,[o]:W}});return}if(t&&typeof t=="object"&&t.type==="file_start"){const{fileId:u,fileName:l,fileSize:w,mimeType:k,totalChunks:O,messageType:Q}=t,W={id:u,fileName:l,fileSize:w,mimeType:k,totalChunks:O,receivedChunks:new Map,progress:0,messageType:Q||"file"};oe.current.set(u,W),N({fileId:u,fileName:l,progress:0});return}if(t&&typeof t=="object"&&t.type==="file_chunk"){const{fileId:u,chunkIndex:l,data:w}=t,k=oe.current.get(u);if(!k)return;k.receivedChunks.set(l,w);const O=Math.round(k.receivedChunks.size/k.totalChunks*100);k.progress=O,N({fileId:u,fileName:k.fileName,progress:O});return}if(t&&typeof t=="object"&&t.type==="file_end"){const{fileId:u}=t,l=oe.current.get(u);if(!l)return;const w=[];for(let Q=0;Q<l.totalChunks;Q++){const W=l.receivedChunks.get(Q);W&&w.push(W)}const k=new Blob(w),O={id:me(),senderId:o,content:l.fileName,timestamp:Date.now(),receivedAt:Date.now(),status:"delivered",type:l.messageType,file:{name:l.fileName,size:l.fileSize,mimeType:l.mimeType,data:k}};x(Q=>{const W=Q[o]||{peerId:o,messages:[],lastUpdated:Date.now(),unreadCount:0},re={...W,messages:[...W.messages,O],lastUpdated:Date.now(),unreadCount:n===o?0:W.unreadCount+1};return ce(ee.current,re),{...Q,[o]:re}}),ae.current(o,{type:"receipt",messageId:O.id,status:"delivered",timestamp:Date.now()}),oe.current.delete(u),N(null);return}if(t&&typeof t=="object"&&t.type==="sync_request"){z("incoming"),s(o);return}if(t&&typeof t=="object"&&t.type==="sync_reject"){z("idle"),s(null),alert(`${o} declined the sync request.`);return}if(t&&typeof t=="object"&&t.type==="sync_cancel"){z("idle"),s(null);return}if(t&&typeof t=="object"&&(t.type==="sync_data_initial"||t.type==="sync_data_final")){const u=t.messages;if(!Array.isArray(u))return;x(l=>{const w=l[o]||{peerId:o,messages:[],lastUpdated:Date.now(),unreadCount:0},k=new Set(w.messages.map(re=>re.id)),O=u.filter(re=>!k.has(re.id));if(O.length===0&&t.type==="sync_data_final")return l;const Q=[...w.messages,...O].sort((re,Et)=>re.timestamp-Et.timestamp),W={...w,messages:Q};return ce(ee.current,W),t.type==="sync_data_initial"&&ae.current(o,{type:"sync_data_final",messages:Q}),{...l,[o]:W}}),f({phase:t.type==="sync_data_initial"?"Receiving":"Merging",count:u.length}),setTimeout(()=>{z("idle"),s(null),f(null)},500);return}const g=t.id||me(),E=t.timestamp||Date.now(),j=t._encrypted===!0;let A;typeof t=="string"?A={id:g,senderId:o,content:t,timestamp:E,receivedAt:Date.now(),status:"delivered",type:"text",encrypted:!1}:A={id:g,senderId:o,content:t.content||"",timestamp:E,receivedAt:Date.now(),status:"delivered",type:t.type||"text",file:t.file,encrypted:j},!(!A.content&&!A.file)&&(ae.current(o,{type:"receipt",messageId:g,status:"delivered",timestamp:Date.now()}),x(u=>{const l=u[o]||{peerId:o,messages:[],lastUpdated:Date.now(),unreadCount:0},w={...l,messages:[...l.messages,A],lastUpdated:Date.now(),unreadCount:n===o?0:l.unreadCount+1},k={...u,[o]:w};return ce(ee.current,w),k}))},[n]),ot=a.useCallback(o=>{x(t=>{if(!t[o]){const g={peerId:o,messages:[],lastUpdated:Date.now(),unreadCount:0};return ce(ee.current,g),{...t,[o]:g}}return t}),Ce.current().then(t=>{t&&ae.current(o,{type:"key_exchange",...t})}),window.innerWidth>=768&&!n&&T(o)},[n]),rt=a.useCallback(o=>{le(t=>({...t,[o]:!1}))},[]),{myId:ie,activeConnectionsCount:at,connectToPeer:pe,disconnectPeer:he,sendMessage:te,updateId:Ke,peerError:Ne,isReady:de,connectionStates:ge,isReconnecting:it}=os({config:K,sessionId:y,onMessageReceived:Re,onConnectionOpened:ot,onConnectionClosed:rt,onConnectionLimitExceeded:o=>{var g;const t=((g=se[o])==null?void 0:g.name)||o.slice(0,8);d(`Disconnected "${t}" - max ${tt} connections reached`),setTimeout(()=>d(null),4e3)}}),{myFingerprint:ct,createKeyExchange:Ae,handleKeyExchange:Oe,encrypt:ye,decrypt:_e,getPeerFingerprint:lt,hasPeerKey:we,markPeerVerified:ut,exportMyKeys:dt,importMyKeys:ft}=rs({sessionId:y,onKeyChange:(o,t,g)=>{m({peerId:o,oldFingerprint:t,newFingerprint:g})}}),mt=a.useRef(ye),Ue=a.useRef(_e);a.useEffect(()=>{mt.current=ye,Ue.current=_e,xe.current=Oe,Ce.current=Ae,Ee.current=we},[ye,_e,Oe,Ae,we]);const{rooms:be,activeRoomId:fe,setActiveRoomId:ke,createRoom:pt,joinRoom:Me,leaveRoom:gt,closeRoom:ht,sendRoomMessage:yt,isHost:Fe,handleRoomProtocol:Ie}=fs({myId:ie,sendMessage:te,connectToPeer:pe,disconnectPeer:he,connectionStates:ge,isReady:de});a.useEffect(()=>{je.current=Ie},[Ie]),a.useEffect(()=>{ae.current=te},[te]),a.useEffect(()=>{ve.current=Re},[Re]),a.useEffect(()=>{de&&Y&&(console.log("Auto-joining room from URL:",Y),Me(Y),r("rooms"),Z(null))},[de,Y,Me]),a.useEffect(()=>{de&&H&&H!==ie&&(console.log("Auto-connecting to peer from URL:",H),pe(H),T(H),X(null))},[de,H,ie,pe]);const wt=async o=>{if(!n)return;const t=me(),g=Date.now();let E={id:t,timestamp:g};typeof o=="string"?(E.content=o,E.type="text"):E={...E,...o};const j=we(n);let A=!1,F=!1;if(j){const u=await ye(n,JSON.stringify(E));u?(A=te(n,{type:"encrypted_message",payload:u}),F=!0):A=te(n,E)}else A=te(n,E);if(A){const u={id:t,senderId:ie,content:E.content||"",timestamp:g,status:"sent",type:E.type,file:E.file,encrypted:F};x(l=>{const w=l[n]||{peerId:n,messages:[],lastUpdated:Date.now(),unreadCount:0},k={...w,messages:[...w.messages,u],lastUpdated:Date.now()},O={...l,[n]:k};return ce(ee.current,k),O}),setTimeout(()=>{x(l=>{const w=l[n];if(!w)return l;const k=w.messages.find(O=>O.id===t);if(k&&k.status==="sent"){const O=w.messages.map(W=>W.id===t?{...W,status:"failed"}:W),Q={...w,messages:O};return ce(ee.current,Q),{...l,[n]:Q}}return l})},1e4)}else{const u={id:t,senderId:ie,content:E.content||"",timestamp:g,status:"failed",type:E.type,file:E.file};x(l=>{const w=l[n]||{peerId:n,messages:[],lastUpdated:Date.now(),unreadCount:0},k={...w,messages:[...w.messages,u],lastUpdated:Date.now()},O={...l,[n]:k};return ce(ee.current,k),O})}},bt=async(o,t,g)=>{if(!n)return;const E=Math.ceil(t.size/Pe),j=await t.arrayBuffer();te(n,{type:"file_start",fileId:o,fileName:t.name,fileSize:t.size,mimeType:t.type,totalChunks:E,messageType:g});const A={id:o,senderId:ie,content:t.name,timestamp:Date.now(),status:"sending",type:g,file:{name:t.name,size:t.size,mimeType:t.type,data:new Blob([j])}};x(F=>{const u=F[n]||{peerId:n,messages:[],lastUpdated:Date.now(),unreadCount:0},l={...u,messages:[...u.messages,A],lastUpdated:Date.now()};return{...F,[n]:l}});for(let F=0;F<E;F++){const u=F*Pe,l=Math.min(u+Pe,t.size),w=j.slice(u,l);te(n,{type:"file_chunk",fileId:o,chunkIndex:F,data:w});const k=Math.round((F+1)/E*100);p({fileId:o,progress:k}),await new Promise(O=>setTimeout(O,10))}te(n,{type:"file_end",fileId:o}),x(F=>{const u=F[n];if(!u)return F;const l=u.messages.map(k=>k.id===o?{...k,status:"sent"}:k),w={...u,messages:l};return ce(ee.current,w),{...F,[n]:w}}),p(null)},St=o=>{if(!n)return;const t=se[n];if(!t)return;const g=t.messages.find(j=>j.id===o);if(!g||g.status!=="failed")return;te(n,{id:g.id,content:g.content,timestamp:g.timestamp})&&(x(j=>{const A=j[n];if(!A)return j;const F=A.messages.map(l=>l.id===o?{...l,status:"sent"}:l),u={...A,messages:F};return ce(ee.current,u),{...j,[n]:u}}),setTimeout(()=>{x(j=>{const A=j[n];if(!A)return j;const F=A.messages.find(u=>u.id===o);if(F&&F.status==="sent"){const u=A.messages.map(w=>w.id===o?{...w,status:"failed"}:w),l={...A,messages:u};return ce(ee.current,l),{...j,[n]:l}}return j})},1e4))},Ct=()=>{n&&(te(n,{type:"sync_request"}),z("outgoing"),s(n))},Rt=()=>{e&&te(e,{type:"sync_cancel"}),z("idle"),s(null)},_t=()=>{if(!e)return;const o=se[e],t=o?o.messages:[];z("outgoing"),f({phase:"Sending",count:t.length}),te(e,{type:"sync_data_initial",messages:t}),setTimeout(()=>{z("idle"),s(null),f(null)},800)},kt=()=>{e&&(te(e,{type:"sync_reject"}),z("idle"),s(null))},Te=o=>{pe(o),T(o),M(!1)},Mt=()=>{n&&confirm("Are you sure you want to delete this conversation?")&&(he(n),x(o=>{const t={...o};return delete t[n],zt(ee.current,n),t}),T(null))},Ge=(o,t)=>{x(g=>{const E=g[o];if(!E)return g;const j={...E,name:t.trim()===""?void 0:t.trim()};return ce(ee.current,j),{...g,[o]:j}})},Dt=async o=>{if(o!==y){T(null),x({}),Se(o),b(o);try{const t=await Xe(o);x(t)}catch(t){console.error("Failed to load chats for session:",t)}}},Pt=async()=>{const o=me(),t={id:o,createdAt:Date.now()};Ze(t);const g=[...G,t];C(g),Se(o),b(o),x({}),T(null),S(!1)},xt=async o=>{if(o!==y){qt(o);try{await Wt(o)}catch(t){console.error("Failed to delete chats for session:",t)}C(t=>t.filter(g=>g.id!==o))}},vt=Object.keys(ge).filter(o=>ge[o]==="connected");return U?J.jsxs("div",{className:"flex h-screen overflow-hidden bg-slate-950 text-slate-100 font-sans selection:bg-primary-500/30 relative",children:[c&&J.jsx("div",{className:"absolute bottom-20 left-1/2 -translate-x-1/2 z-50 animate-in fade-in slide-in-from-bottom-4",children:J.jsxs("div",{className:"bg-yellow-500/10 border border-yellow-500/50 backdrop-blur-md text-yellow-200 px-4 py-3 rounded-lg shadow-xl flex items-center gap-3",children:[J.jsx("span",{className:"text-sm font-medium",children:c}),J.jsx("button",{onClick:()=>d(null),className:"p-1 hover:bg-yellow-500/20 rounded-full transition-colors",children:J.jsx(Nt,{className:"w-4 h-4"})})]})}),J.jsx("div",{className:`
        ${n||fe||B?"hidden md:flex":"flex"}
        w-full md:w-80 flex-col border-r border-slate-800
      `,children:J.jsx(Vt,{myId:ie,chats:se,activeConnections:vt,onSelectPeer:o=>{T(o),ke(null),M(!1),ge[o]!=="connected"&&pe(o)},onConnect:Te,onRenameChat:Ge,onShowDashboard:()=>M(!0),peerError:Ne,isReady:de,onRetry:()=>Ke(ie),sessions:G,activeSessionId:y,onSwitchSession:Dt,onCreateNewSession:()=>S(!0),onDeleteSession:xt,isReconnecting:it,rooms:be,onSelectRoom:o=>{ke(o),T(null)}})}),J.jsx("div",{className:`
        ${n||fe||B?"flex":"hidden md:flex"}
        flex-1 flex-col min-w-0 bg-slate-950
      `,children:fe&&be[fe]?J.jsx(ts,{myId:ie,room:be[fe],onSendMessage:yt,onLeaveRoom:Fe(fe)?ht:gt,onBack:()=>{ke(null)},isHost:Fe(fe)}):J.jsx(Xt,{myId:ie,peerId:n||"",session:n?se[n]:void 0,connectionState:n&&ge[n]||"disconnected",onSendMessage:wt,onDeleteChat:Mt,onConnect:()=>n&&Te(n),onCancelConnection:()=>n&&he(n),isReady:de,activeConnectionsCount:at,totalChats:Object.keys(se).length,totalRooms:Object.keys(be).length,isPeerTyping:n?ue[n]:!1,sendMessage:te,peerError:Ne,onRetry:()=>Ke(ie),onRenameChat:o=>n&&Ge(n,o),onResendMessage:St,onRequestSync:Ct,onSendFileChunked:bt,sendingProgress:R,receivingProgress:P,peerFingerprint:n?lt(n):null,isEncrypted:n?we(n):!1})}),J.jsx(Qt,{status:ne,targetPeerId:e,peerName:e?(Je=se[e])==null?void 0:Je.name:void 0,progress:i,onCancel:Rt,onAccept:_t,onReject:kt}),J.jsx(Yt,{isOpen:q,onClose:()=>S(!1),onConfirm:Pt}),I&&J.jsx(Zt,{config:K,onSave:nt,myFingerprint:ct,onExportKeys:dt,onImportKeys:ft}),J.jsx(es,{warning:_,peerName:_?(He=se[_.peerId])==null?void 0:He.name:void 0,onDisconnect:()=>{_&&(he(_.peerId),m(null))},onTrust:()=>{_&&(ut(_.peerId),m(null))}}),J.jsx(ss,{isOpen:h,onClose:()=>$(!1),onCreateRoom:o=>{const t=pt(o);return r("rooms"),t},myId:ie}),J.jsx(ns,{isOpen:D,onClose:()=>V(!1),onJoinRoom:o=>{Me(o),V(!1),r("rooms")},pendingRoomId:Y})]}):J.jsx("div",{className:"h-screen w-screen flex items-center justify-center bg-slate-950 text-white",children:"Initializing..."})}const st=document.getElementById("root");if(!st)throw new Error("Could not find root element to mount to");const ps=At.createRoot(st);ps.render(J.jsx(Ot.StrictMode,{children:J.jsx(ms,{})}));export{et as D,Pe as F,js as M,Es as g,cs as u};
